#include <iostream>
#include <fstream>
#include <charconv>
#include <map>
#include <string>

#include "pugixml.hpp"

unsigned fromHex(std::string_view x)
{
    long long r;
    auto beg = x.data();
    auto end = beg + x.length();
    auto res = std::from_chars(beg, end, r, 16);
    if (res.ec != std::errc() || res.ptr != end) {
        std::string errm = "[fromHex] Cannot parse hex ";
        errm.append(x);
        throw std::invalid_argument(errm);
    }
    return r;
}

// Optimum size (according to Unicode 15 beta)
//
// Block = 4: 157 blocks, 7827 items in main lookup table
//  157·16·4 + 7827 = 17875
//
// Block = 5: 89 blocks, 3914 items in main lookup table
//  89·32·4 + 3914 = 15306
//
// Block = 6: 57 blocks, 1957 in main lookup table
//  57·64·4 + 1957 = 16549

constexpr int BLOCKSHIFT = 5;
constexpr int BLOCKSIZE = 1 << BLOCKSHIFT;
constexpr int BLOCKMASK = BLOCKSIZE - 1;

struct BlockInfo {
    int count = 0;
    int iArray = -1;
    int data[BLOCKSIZE] { 0 };
};

int main()
{
    try {
        std::map<std::string, unsigned> touchedScripts;

        std::cout << "Loading XML..." << std::flush;
        pugi::xml_document doc;
        bool q =doc.load_file("ucd.all.flat.xml");
        if (!q) {
            throw std::logic_error("Cannot load 'ucd.all.flat.xml'");
        }
        std::cout << "OK" << std::endl;

        auto hRoot = doc.child("ucd");
        auto hRepertoire = hRoot.child("repertoire");

        std::map<int, BlockInfo> mBlocks;

        std::cout << "Generating table..." << std::flush;
        for (auto hChar : hRepertoire.children("char")) {
            std::string_view sCf = hChar.attribute("scf").as_string();
            if (sCf.empty() || sCf == "#")
                continue;

            char32_t cf = fromHex(sCf);

            auto sCp = hChar.attribute("cp").as_string();
            char32_t cp = fromHex(sCp);

            auto sScript = hChar.attribute("sc").as_string();
            touchedScripts.try_emplace(sScript, cp);

            bool isCpAux = (cp >= 65536);
            bool isCfAux = (cf >= 65536);
            if (isCpAux ^ isCfAux) {
                std::cout << "Case folding changed plane: " << std::hex << isCpAux
                          << " -> " << isCfAux << std::endl;
            }

            int iBlock = cp >> BLOCKSHIFT;
            int iInside = cp & BLOCKMASK;
            auto& blk = mBlocks[iBlock];
            ++blk.count;
            blk.data[iInside] = cf;
        }
        std::cout << "OK" << std::endl;

        std::ofstream os("auto_casefold.cpp");
        os << "// This file is autogenerated!" "\n";
        os << R"(#include "../internal/auto.hpp")" "\n";

        os << "constinit const char32_t mojibake::detail::simpleCfBlocks["
                    << mBlocks.size() << "][" << BLOCKSIZE << "] = {" "\n";
        int currIndex = -1;
        int maxBlock = 0;
        for (auto& v : mBlocks) {
            // index
            ++currIndex;
            v.second.iArray = currIndex;

            maxBlock = v.first;

            os << " {";
            for (size_t j = 0; j < BLOCKSIZE; ++j) {
                if (j % 16 == 0 && j != 0) {
                    os << "\n  ";
                }
                auto result = v.second.data[j];
                if (result == 0)
                    result = (v.first << BLOCKSHIFT) | j;
                os << result << ',';
            }
            //os << v.first << " " << v.second.count << '\n';
            os << " }," "\n";
        }
        os << "};" "\n";

        ++maxBlock;

        os << "constinit const signed char mojibake::detail::simpleCfLookup["
                    << maxBlock << "] {";
        for (int i = 0; i < maxBlock; ++i) {
            auto what = mBlocks.find(i);
            auto iArray = (what == mBlocks.end()) ? -1 : what->second.iArray;
            if (i % 16 == 0)
                os << "\n ";
            os << iArray << ",";
        }
        os << "\n" "};" "\n";
        os.close();

        os.open("~touched_scripts.log");
        for (auto& [k,v] : touchedScripts) {
            os << k << ' ' << std::hex << v << '\n';
        }
        os.close();

        return 0;
    } catch (const std::exception& e) {
        std::cout << "ERROR: " << e.what() << std::endl;
        return 1;
    }
}
